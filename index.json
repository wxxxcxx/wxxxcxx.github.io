[{"content":"在某次更新过程中强制重启。之后发现无法更新软件包。使用 pacman -S 安装任何软件都提示如下错误：\nerror: GPGME error: Invalid crypto engine error: ***: missing required signature 查找一些资料说可以通过重新安装 gpgme和 keyring解决，但是由于pacman 安装软件包时也会校验签名导致无法重新安装。\n期间折腾了好久，突然想到 pacman 好像可以通过配置文件设置是否校验软件包，试了一下果然好了。\n操作步骤 修改 SigLevel ：\nsudo vim /etc/pacman.conf 将 [core] 的 SigLevel 改为 Never并保存，如下：\n[core] SigLevel = Never #SigLevel = PackageRequired 移除无效的 key：\nsudo rm -r /etc/pacman.d/gnupg 重新安装 gnupg和 keyring：\nsudo pacman -Sy gnupg archlinux-keyring manjaro-keyring 初始化 keyring：\nsudo pacman-key --init 加载签名：\nsudo pacman-key --populate archlinux manjaro 刷新签名：\nsudo pacman-key --refresh-keys 清除已下载的包缓存：\nsudo pacman -Sc 最后将 SigLevel 的值改回来就行了。\n","permalink":"https://wxxxcxx.com/post/archlinux-missing-required-signature/","summary":"在某次更新过程中强制重启。之后发现无法更新软件包。使用 pacman -S 安装任何软件都提示如下错误：\nerror: GPGME error: Invalid crypto engine error: ***: missing required signature 查找一些资料说可以通过重新安装 gpgme和 keyring解决，但是由于pacman 安装软件包时也会校验签名导致无法重新安装。\n期间折腾了好久，突然想到 pacman 好像可以通过配置文件设置是否校验软件包，试了一下果然好了。\n操作步骤 修改 SigLevel ：\nsudo vim /etc/pacman.conf 将 [core] 的 SigLevel 改为 Never并保存，如下：\n[core] SigLevel = Never #SigLevel = PackageRequired 移除无效的 key：\nsudo rm -r /etc/pacman.d/gnupg 重新安装 gnupg和 keyring：\nsudo pacman -Sy gnupg archlinux-keyring manjaro-keyring 初始化 keyring：\nsudo pacman-key --init 加载签名：\nsudo pacman-key --populate archlinux manjaro 刷新签名：\nsudo pacman-key --refresh-keys 清除已下载的包缓存：","title":"Archlinux 更新软件包时提示签名错误的解决办法"},{"content":"之前网站部署在阿里云香港的 VPS 上，最近发现某些网络环境下HTTPS打不开网站，开始还以为是 GFW 的问题。但是测试发现 4G 网络访问正常，HTTP 也能正常访问。搜索了一番发现了很多相似的情况。问题是 SSL ClientHello 包无法获得响应导致的。使用 Wrieshick 抓包的结果也证实了这一点。这个锅先甩给运营商吧。\n目前还不知道更换证书或更换 VPS 能不能解决这个问题（感觉即使能解决也不是持久之计，有条件的同学还是备案用境内的 VPS ）。\n由于域名转入备案太麻烦，而且正巧发现 Github Pages 对自定义域名支持 HTTPS 了，所以决定吧网站迁移到 Github Pages 上。\n迁移文件 选择站点类型 GitHub Pages 站点的静态文件都保存在 Repository 中。GitHub Pages 提供了 User or organization site 和 Project site 两种方式托管静态文件。\n两种方式基本没有什么区别。由于我要部署的是个人博客，因此我选择使用 User or organization site。\n顺带说一句，GitHub Pages 是支持 Jekyll 模版语法。所以可以通过 Jekyll 来“动态”生成网站。\n创建\u0026amp;配置Repository 首先需要创建一个以 username.GitHub.io 命名的 Repository。注意替换 username为你的用户名。\n创建好 Repository 后按正常的提交代码的流程将站点文件提交到 master 分支。\n如果操作正确而且如果你不需要绑定域名的话，现在你就可以通过访问 username.github.io 访问你的网站了。\n绑定域名\u0026amp;开启 HTTPS 首先在 Repository -\u0026gt; Settings -\u0026gt; GitHub Pages -\u0026gt; Custom domain 中填写需要绑定的域名。\n下面开始解析域名 CNAME 和 A 记录二选一即可。\n添加 CNAME 添加一条 CNAME 记录到 username.github.io 即可。\n使用一下命令查看效果：\n$ dig mydomain.com +noall +answer mydomain.com\t3600\tIN A\tXXX.XXX.XXX.XXX $ dig username.github.io +noall +answer username.github.io\t3600\tIN A\tXXX.XXX.XXX.XXX XXX.XXX.XXX.XXX 为服务器 IP，两个命令的 IP 如果一致的话，说明已经生效了。\n添加 A 记录 在域名的 DNS 设置中添加 4 条 A 记录分别对印到：\n185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 如果生效了的话，使用 dig命令应该可以看到 4 条和上面 IP 对印的结果。\n最后需要确保 Repository -\u0026gt; Settings -\u0026gt; GitHub Pages -\u0026gt; Custom domain 中的 Enforce HTTPS 是勾选状态。\n最后，访问 https://mydomain.com 应该可以看到绿色的小锁了。\nTips 注意上文中出现的 username 全部需要替换为也登陆使用的用户名。 GitHub Pages 支持一个站点同时绑定顶级域名和 www 子域名，但是据文档所说每个站点只能绑定一个非 www 的子域名。 如果之前域名有解析到其他位置的话，在进行操作之前可以先将域名的 TTL 设置短一点，方便修改解析后快速生效。 ","permalink":"https://wxxxcxx.com/post/deploying-static-site-with-github-pages/","summary":"之前网站部署在阿里云香港的 VPS 上，最近发现某些网络环境下HTTPS打不开网站，开始还以为是 GFW 的问题。但是测试发现 4G 网络访问正常，HTTP 也能正常访问。搜索了一番发现了很多相似的情况。问题是 SSL ClientHello 包无法获得响应导致的。使用 Wrieshick 抓包的结果也证实了这一点。这个锅先甩给运营商吧。\n目前还不知道更换证书或更换 VPS 能不能解决这个问题（感觉即使能解决也不是持久之计，有条件的同学还是备案用境内的 VPS ）。\n由于域名转入备案太麻烦，而且正巧发现 Github Pages 对自定义域名支持 HTTPS 了，所以决定吧网站迁移到 Github Pages 上。\n迁移文件 选择站点类型 GitHub Pages 站点的静态文件都保存在 Repository 中。GitHub Pages 提供了 User or organization site 和 Project site 两种方式托管静态文件。\n两种方式基本没有什么区别。由于我要部署的是个人博客，因此我选择使用 User or organization site。\n顺带说一句，GitHub Pages 是支持 Jekyll 模版语法。所以可以通过 Jekyll 来“动态”生成网站。\n创建\u0026amp;配置Repository 首先需要创建一个以 username.GitHub.io 命名的 Repository。注意替换 username为你的用户名。\n创建好 Repository 后按正常的提交代码的流程将站点文件提交到 master 分支。\n如果操作正确而且如果你不需要绑定域名的话，现在你就可以通过访问 username.github.io 访问你的网站了。","title":"使用 Github Pages 部署静态网站"},{"content":"前言 事务隔离级别是数据库管理系统中的一个重要概念，用于控制并发执行事务时的隔离程度。M选择适当的事务隔离级别对于确保数据的一致性和并发控制非常重要。根据具体的业务需求和数据库性能要求，需要综合考虑选择合适的隔离级别。\n什么是脏读、不可重复读、幻读 思考一个问题：一张表中有一条记录。事务A会对这条记录进行修改。事务B在事务A修改的过程中一直读取这条记录。那么B读到的记录回事什么样的呢？\n脏读\n当A事务修改了这条记录但是未提交时，如果B事务能够读到A修改过的记录值，这总情况就是发生的脏读。\n不可重复读\n如果B事务能够在A提交事务前读到未修改过的值，并且能在A事务提交后读取到修改过的值——两次读到的值不一致，这就是不可重复读\n幻读\n当B事务使用 select count(*) 读取一张表的时候，如果A事务对这张表进行了增加或删除，如果在B事务中读到的值不一致那么说明发生了幻读。\nMySQL 事务隔离级别 MySQL事务拥有四种隔离级别：\n读未提交（Read Uncommitted）：允许一个事务读取另一个未提交的事务所做的修改，可能导致脏读问题。 读已提交（Read Committed）：保证一个事务只能读取到已经提交的事务所做的修改，避免了脏读问题。 可重复读（Repeatable Read）：保证一个事务在执行期间多次读取同一数据时，能够得到一致的结果，避免了不可重复读问题。 串行化（Serializable）：最高隔离级别，确保并发执行的事务之间完全隔离，避免了幻读问题。 ","permalink":"https://wxxxcxx.com/post/mysql-transaction-isolation-level/","summary":"前言 事务隔离级别是数据库管理系统中的一个重要概念，用于控制并发执行事务时的隔离程度。M选择适当的事务隔离级别对于确保数据的一致性和并发控制非常重要。根据具体的业务需求和数据库性能要求，需要综合考虑选择合适的隔离级别。\n什么是脏读、不可重复读、幻读 思考一个问题：一张表中有一条记录。事务A会对这条记录进行修改。事务B在事务A修改的过程中一直读取这条记录。那么B读到的记录回事什么样的呢？\n脏读\n当A事务修改了这条记录但是未提交时，如果B事务能够读到A修改过的记录值，这总情况就是发生的脏读。\n不可重复读\n如果B事务能够在A提交事务前读到未修改过的值，并且能在A事务提交后读取到修改过的值——两次读到的值不一致，这就是不可重复读\n幻读\n当B事务使用 select count(*) 读取一张表的时候，如果A事务对这张表进行了增加或删除，如果在B事务中读到的值不一致那么说明发生了幻读。\nMySQL 事务隔离级别 MySQL事务拥有四种隔离级别：\n读未提交（Read Uncommitted）：允许一个事务读取另一个未提交的事务所做的修改，可能导致脏读问题。 读已提交（Read Committed）：保证一个事务只能读取到已经提交的事务所做的修改，避免了脏读问题。 可重复读（Repeatable Read）：保证一个事务在执行期间多次读取同一数据时，能够得到一致的结果，避免了不可重复读问题。 串行化（Serializable）：最高隔离级别，确保并发执行的事务之间完全隔离，避免了幻读问题。 ","title":"彻底弄懂 MySQL 事务的隔离级别"},{"content":"","permalink":"https://wxxxcxx.com/tags/","summary":"","title":"Tags"}]